"""
Email service for the Lead Qualification System.
"""
import smtplib
import asyncio
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime
from config import EMAIL_USER, EMAIL_APP_PASSWORD, EMAIL_ENABLED, EMAIL_ROUTING, EMAIL_DEPUPE_WINDOW

# Cache for lead deduplication
LEAD_INFO_CACHE = {}
LEAD_EMAIL_CACHE = {}


def send_email_message(to_email, subject, body, cc=None, log_prefix="EMAIL"):
    """Core email sending function."""
    # Import here to avoid circular imports
    from utils import log_system_message
    
    log_system_message(f"{log_prefix}: Sending to {to_email} - {subject}")
    
    if not EMAIL_ENABLED:
        message = f"Email disabled. Would send to {to_email}: {subject}"
        log_system_message(message)
        return message
    
    try:
        # Create and configure message
        msg = MIMEMultipart()
        msg['From'] = EMAIL_USER
        msg['To'] = to_email
        msg['Subject'] = subject
        if cc:
            msg['Cc'] = cc
        msg.attach(MIMEText(body, 'html'))
        
        # Send via Gmail SMTP
        with smtplib.SMTP('smtp.gmail.com', 587) as server:
            server.starttls()
            server.login(EMAIL_USER, EMAIL_APP_PASSWORD)
            recipients = [to_email] + (cc.split(',') if cc else [])
            server.sendmail(EMAIL_USER, recipients, msg.as_string())
        
        success_msg = f"Email sent successfully to {to_email}"
        log_system_message(f"{log_prefix}: ✅ {success_msg}")
        return success_msg
    except Exception as e:
        error_msg = f"Failed to send email: {str(e)}"
        log_system_message(f"{log_prefix}: ❌ {error_msg}")
        return error_msg


def create_lead_email_body(lead_type, lead_name, company=None, email=None, phone=None, details=None, priority="normal"):
    """Create HTML email body for lead notifications."""
    return f"""
    <h2>New {lead_type.title()} Lead ({priority.upper()} Priority)</h2>
    <p><strong>Name:</strong> {lead_name}</p>
    <p><strong>Company:</strong> {company or 'N/A'}</p>
    <p><strong>Email:</strong> {email or 'N/A'}</p>
    <p><strong>Phone:</strong> {phone or 'N/A'}</p>
    <p><strong>Details:</strong> {details or 'N/A'}</p>
    <hr>
    <p><em>This email was automatically generated by the Lead Qualification System.</em></p>
    """


def route_lead_email(lead_type, lead_name, **lead_info):
    """Route lead to appropriate email address."""
    destination = EMAIL_ROUTING.get(lead_type.lower(), EMAIL_USER)
    subject = f"New {lead_type.title()} Lead: {lead_name}"
    body = create_lead_email_body(lead_type, lead_name, **lead_info)
    
    # Import here to avoid circular imports
    from utils import log_system_message
    log_system_message(f"ROUTING: {lead_type} lead '{lead_name}' to {destination}")
    return send_email_message(destination, subject, body, log_prefix="ROUTING")


async def force_lead_email(lead_type, lead_name, lead_info=None):
    """Force email sending for classified leads with deduplication."""
    if not lead_info:
        lead_info = {}
    
    # Import here to avoid circular imports
    from utils import log_system_message
    
    # Normalize and cache lead information
    cache_key = f"{lead_type}:{lead_name}".lower()
    cached_info = LEAD_INFO_CACHE.get(cache_key, {})
    
    # Update cached info with new data
    for key, value in lead_info.items():
        if value and value not in ["Not provided", "No additional details"]:
            cached_info[key] = value
    
    LEAD_INFO_CACHE[cache_key] = cached_info
    email = cached_info.get("email")
    
    # Skip if no email available
    if not email or email == "Not provided":
        log_system_message(f"AUTO EMAIL: No email for {lead_type} lead {lead_name}; waiting")
        return f"Waiting for email address for {lead_name}"
    
    # Check deduplication
    now_ts = datetime.now().timestamp()
    last_sent = LEAD_EMAIL_CACHE.get(cache_key, {"ts": 0, "email": None})
    
    # Send if email changed or enough time passed
    should_send = (
        last_sent["email"] != email or 
        now_ts - last_sent["ts"] > EMAIL_DEPUPE_WINDOW
    )
    
    if not should_send:
        elapsed = int(now_ts - last_sent["ts"])
        log_system_message(f"AUTO EMAIL: Skipping duplicate for {lead_name} (sent {elapsed}s ago)")
        return f"Skipped duplicate email for {lead_name}"
    
    # Send email and update cache
    LEAD_EMAIL_CACHE[cache_key] = {"ts": now_ts, "email": email}
    result = route_lead_email(lead_type, lead_name, **cached_info)
    log_system_message(f"AUTO EMAIL: Force email result for {lead_name}: {result}")
    return result


def send_test_email():
    """Send test email to verify configuration."""
    if not EMAIL_ENABLED:
        import streamlit as st
        st.sidebar.warning("⚠️ Email disabled. Configure EMAIL_USER and EMAIL_APP_PASSWORD.")
        return
    
    body = f"""
    <h1>Test Email</h1>
    <p>This is a test email from the Lead Qualification System.</p>
    <p>If you're receiving this, your email configuration is working correctly.</p>
    <hr>
    <p><strong>Configuration:</strong></p>
    <ul>
        <li>From: {EMAIL_USER}</li>
        <li>SMTP: smtp.gmail.com:587</li>
        <li>Time: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</li>
    </ul>
    """
    
    result = send_email_message(EMAIL_USER, "Test Email from Lead Qualification System", body, log_prefix="TEST")
    
    import streamlit as st
    if "successfully" in result:
        st.sidebar.success("✅ Test email sent successfully!")
    else:
        st.sidebar.error(f"❌ Failed to send test email: {result}")
